介绍一些组件
==============

原文：[Introduction to some Components]
(http://forums.kleientertainment.com/topic/47542-introduction-to-some-components/?hl=overridesymbol)

翻译：@czfshine

>**Prefabs**(预设物）, **Components**（组件）, **Stategraphs**（状态图）, 这一些名词意味着是什么呢？我希望它们像XYZ一样简单。

目录：
=================

General（一般）

Armor（护甲）

Beard(胡子）

Burnable

Container

Cookable

Dapperness

Eater

Edible

Equippable

Finite Uses

Harvestable

Health

Hunger

Insulator

Inventory-Item

Perishable

Pickable

Propagator

Repairable

Sanity-Aura

Talker

Tool

Tradable

Useable Item

Workable

Light


General（一般）
========================

```
假设你已经熟悉基本的Lua
```

一个组件(component)是一些为预设件（prefabs）准备的代码,
通常组件是来描述一个单一的属性（例：生命，饥饿，攻击）,
允许在一个预设件上用各种各样的创意组合各种组件，
仍然困惑于这段句话吗?[去看它们的不同点](http://forums.kleientertainment.com/topic/25850-wots-the-diff-prefabs-components-stategraphs-and-brains/)


要使用一个组件,你首先需要将它添加到你的预设件:

```lua 
inst:AddComponent("MyComponent")
```

然后你可以自定义具体的细节:

```lua
inst.components.MyComponent.maxvalue = 100
inst.components.MyComponent:SetSomething(true)
```

如果组件有提供,当你需要时你可以访问该组件的某个函数，或给组件设置一组函数:

```lua
inst.components.MyComponent:BeFun() --prepared function
inst.components.MyComponent.befunfn = BackflipFn --set a function
```
这些只是理论,选择看下面一些有意义的例子! 或者最好直接去看游戏数据!

Armor（护甲）
==============================

这个组件可以使你的盔甲,具有减少玩家全部或某些类型的伤害的功能.
遗憾的是,该组件还意味着有耐久性。

## 重要的变量 ##

`tags`:标签——盔甲标签只有一个效果，可以抵御有一个的相同的标签的攻击。（table）

`onfinished`:移除护甲--理论上你可以使用这个更换装备或重置属性。(function)

`ontakedamage`: 当受到伤害时触发



## 重要的函数 ##

`InitCondition(amount, absorb_percent) `
初始化护甲，设置耐久度（num amount ），减伤百分比（num absorb_percent)

`SetCondition(amount)`
设置耐久度（num amount ）

## 例子 ##

`hats.lua`

```lua
local function ruinshat_proc(inst, owner) -- forcefield when hit
    inst:AddTag("forcefield")
    inst.components.armor:SetAbsorption(TUNING.FULL_ABSORPTION)
    [....]

    inst.components.armor.ontakedamage = function(inst, damage_amount)
        if owner then
            local sanity = owner.components.sanity
            if sanity then
                local unsaneness = damage_amount * TUNING.ARMOR_RUINSHAT_DMG_AS_SANITY
                sanity:DoDelta(-unsaneness, false)
            end
        end
    end

    inst.active = true

    owner:DoTaskInTime(TUNING.ARMOR_RUINSHAT_DURATION, function()
        [...]
        if inst:IsValid() then
            inst:RemoveTag("forcefield")
            inst.components.armor.ontakedamage = nil
            inst.components.armor:SetAbsorption(TUNING.ARMOR_RUINSHAT_ABSORPTION)
            owner:DoTaskInTime(TUNING.ARMOR_RUINSHAT_COOLDOWN, function() inst.active = false end)
        end
    end)
end

local function tryproc(inst, owner)
    if not inst.active and math.random() < TUNING.ARMOR_RUINSHAT_PROC_CHANCE then
       ruinshat_proc(inst, owner)
    end
end

local function ruins_onunequip(inst, owner)
    [...]
    owner:RemoveEventCallback("attacked", inst.procfn)
end

local function ruins_onequip(inst, owner)
    [....]
    inst.procfn = function() tryproc(inst, owner) end
    owner:ListenForEvent("attacked", inst.procfn)
end

local function ruins()
    local inst = simple()
    inst:AddComponent("armor")
    inst.components.armor:InitCondition(TUNING.ARMOR_RUINSHAT, TUNING.ARMOR_RUINSHAT_ABSORPTION)

    inst.components.equippable:SetOnEquip(ruins_onequip)
    inst.components.equippable:SetOnUnequip(ruins_onunequip)

    return inst
end
```

Beard(胡子）
==================

这个组件使你的生物有胡子，绝燃和剃须必须自己编码。

## 重要变量  ##

`callbacks`：回调表--插入每天胡子的变化状态,一个函数（table）

prize:剃须奖励物品名，通常是“beardhair”（string）

bits:奖励数量（num）

canshavetest:限制能否剃须，返回布尔值与原因（fn [ret] bln,str)

onreset:重置函数，（例：被火烧毁）（fn）

## 重要函数  ##

Reset() --重置，状态回到零天

## 例子  ##

` beefalo.lua`

```lua

local function GetStatus(inst)
    if inst.components.follower.leader ~= nil then
        return "FOLLOWER"
    elseif inst.components.beard and inst.components.beard.bits == 0 then
        return "NAKED"
    end
end

local function fn(Sim)
    [....]
    local hair_growth_days = 3

    inst:AddComponent("beard")
    -- assume the beefalo has already grown its hair
    inst.components.beard.bits = 3
    inst.components.beard.daysgrowth = hair_growth_days + 1
    inst.components.beard.onreset = function()
        inst.sg:GoToState("shaved")
    end
    
    inst.components.beard.canshavetest = function() if not inst.components.sleeper:IsAsleep() then return false, "AWAKEBEEFALO" end return true end
    
    inst.components.beard.prize = "beefalowool"
    inst.components.beard:AddCallback(0, function() -- same as callbacks[0] = function()
        if inst.components.beard.bits == 0 then
            anim:SetBuild("beefalo_shaved_build")
        end
    end)
    inst.components.beard:AddCallback(hair_growth_days, function() --do that for every individual state
        if inst.components.beard.bits == 0 then
            inst.hairGrowthPending = true --for stategraph
        end
    end)
   
    [...]
    return inst
end
```










